#!/bin/sh

# this script is a stripped-down version of original Alpine's setup-disk script
# https://github.com/itoffshore/alpine-linux-scripts/blob/master/setup-disk

. /lib/libalpine.sh

# find filesystem of given mounted dir
find_mount_fs() {
	local mount_point="$1"
	awk "\$2 == \"$mount_point\" {print \$3}" /proc/mounts | tail -n 1
}

# find device for given mounted dir
find_mount_dev() {
	local mnt="$1"
	awk "\$2 == \"$mnt\" { print \$1 }" /proc/mounts | tail -n 1
}

# echo current grsecurity option and set new
set_grsec() {
	local key="$1" value="$2"
	if ! [ -e /proc/sys/kernel/grsecurity/$key ]; then
		return 0
	fi
	cat /proc/sys/kernel/grsecurity/$key
	echo $value > /proc/sys/kernel/grsecurity/$key
}

init_chroot_mounts() {
	local mnt="$1" i=
	for i in proc dev; do
		mkdir -p "$mnt"/$i
		mount --bind /$i "$mnt"/$i
	done
}

cleanup_chroot_mounts() {
	local mnt="$1" i=
	for i in proc dev; do
		umount "$mnt"/$i
	done
}

supported_boot_fs() {
	local supported="ext2 ext3 ext4 btrfs"
	local fs=
	for fs in $supported; do
		[ "$fs" = "$1" ] && return 0
	done
	echo "$1 is not supported. Only supported are: $supported" >&2
	return 1
}

has_bootopt() {
	local opt="$1"
	set -- $(cat /proc/cmdline)
	for i; do
		[ "$i" = "$opt" ] && return 0
	done
	return 1
}

install_mounted_root() {
	local mnt="$1" mnt_boot= boot_fs= root_fs=
	local initfs_features="ata base ide scsi usb virtio"
	local pvs= dev= rootdev= bootdev= extlinux_raidopt= root= modules=
	local kernel_opts="quiet"

	rootdev=$(find_mount_dev "$mnt")
	if [ -z "$rootdev" ]; then
		echo "$mnt does not seem to be a mount point" >&2
		return 1
	fi
	root_fs=$(find_mount_fs "$mnt")
	initfs_features="$initfs_features $root_fs"

	bootdev=$(find_mount_dev "$mnt"/boot)
	if [ -z "$bootdev" ]; then
		bootdev=$rootdev
		mnt_boot="$mnt"
	else
		mnt_boot="$mnt"/boot
	fi
	boot_fs=$(find_mount_fs "$mnt_boot")
	supported_boot_fs "$boot_fs" || return 1

	if [ -n "$VERBOSE" ]; then
		echo "Root device:     $rootdev"
		echo "Root filesystem: $root_fs"
		echo "Boot device:     $bootdev"
		echo "Boot filesystem: $boot_fs"
	fi

	ovlfiles=/tmp/ovlfiles
    lbu package - | tar -C "$mnt" -zxv > "$ovlfiles"

	# generate mkinitfs.conf
	mkdir -p "$mnt"/etc/mkinitfs/features.d
	echo "features=\"$initfs_features\"" > "$mnt"/etc/mkinitfs/mkinitfs.conf

	# apk reads config from target root so we need to copy the config
	mkdir -p "$mnt"/etc/apk/keys/
	cp /etc/apk/keys/* "$mnt"/etc/apk/keys/

	local apkflags="--no-network --initdb --quiet --clean-protected"
	local pkgs=$(cat "$mnt"/etc/apk/world "$mnt"/var/lib/apk/world 2>/dev/null)
	pkgs="$pkgs acct linux-$KERNEL_FLAVOR alpine-base docker"
	local repos=$(sed -e 's/\#.*//' /etc/apk/repositories)
	local repoflags=
	for i in $repos; do
		repoflags="$repoflags --repository $i"
	done

	chroot_caps=$(set_grsec chroot_caps 0)
	init_chroot_mounts "$mnt"
	apk add --root "$mnt" $apkflags --overlay-from-stdin \
		$repoflags $pkgs <$ovlfiles
	local ret=$?
	cleanup_chroot_mounts "$mnt"
	set_grsec chroot_caps $chroot_caps > /dev/null
	return $ret
}

usage() {
	cat <<__EOF__
usage: setup-disk [-hv] [-k kernelflavor] [-m MODE] [-o apkovl] MOUNTPOINT

Install alpine on harddisk.

options:
 -h  Show this help
 -m  Use disk for MODE without asking, where MODE is either 'data' or 'sys'
 -o  Restore system from given apkovl file
 -k  Use kernelflavor instead of $KERNEL_FLAVOR
 -v  Be more verbose about what is happening

__EOF__
	exit 1
}

kver=$(uname -r)
case $kver in
        *-rc[0-9]*) KERNEL_FLAVOR=vanilla;;
        *-[a-z]*) KERNEL_FLAVOR=${kver##*-};;
        *) KERNEL_FLAVOR=vanilla;;
esac

DISK_MODE=
# Parse args
while getopts "hk:m:o:v" opt; do
	case $opt in
		m) DISK_MODE="$OPTARG";;
		k) KERNEL_FLAVOR="$OPTARG";;
		o) APKOVL="$OPTARG";;
		v) VERBOSE=1;;
		*) usage;;
	esac
done
shift $(( $OPTIND - 1))

if [ -d "$1" ]; then
	# install to given mounted root
	install_mounted_root "$(echo $1 |sed 's|/*$||')"
	exit $?
fi

echo "missing path to mounted root" >&2
exit 1
